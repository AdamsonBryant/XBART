# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_abarth')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_abarth')
    _abarth = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_abarth', [dirname(__file__)])
        except ImportError:
            import _abarth
            return _abarth
        try:
            _mod = imp.load_module('_abarth', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _abarth = swig_import_helper()
    del swig_import_helper
else:
    import _abarth
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


import collections

class AbarthParams(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbarthParams, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AbarthParams, name)
    __repr__ = _swig_repr
    __swig_setmethods__["M"] = _abarth.AbarthParams_M_set
    __swig_getmethods__["M"] = _abarth.AbarthParams_M_get
    if _newclass:
        M = _swig_property(_abarth.AbarthParams_M_get, _abarth.AbarthParams_M_set)
    __swig_setmethods__["L"] = _abarth.AbarthParams_L_set
    __swig_getmethods__["L"] = _abarth.AbarthParams_L_get
    if _newclass:
        L = _swig_property(_abarth.AbarthParams_L_get, _abarth.AbarthParams_L_set)
    __swig_setmethods__["N_sweeps"] = _abarth.AbarthParams_N_sweeps_set
    __swig_getmethods__["N_sweeps"] = _abarth.AbarthParams_N_sweeps_get
    if _newclass:
        N_sweeps = _swig_property(_abarth.AbarthParams_N_sweeps_get, _abarth.AbarthParams_N_sweeps_set)
    __swig_setmethods__["Nmin"] = _abarth.AbarthParams_Nmin_set
    __swig_getmethods__["Nmin"] = _abarth.AbarthParams_Nmin_get
    if _newclass:
        Nmin = _swig_property(_abarth.AbarthParams_Nmin_get, _abarth.AbarthParams_Nmin_set)
    __swig_setmethods__["Ncutpoints"] = _abarth.AbarthParams_Ncutpoints_set
    __swig_getmethods__["Ncutpoints"] = _abarth.AbarthParams_Ncutpoints_get
    if _newclass:
        Ncutpoints = _swig_property(_abarth.AbarthParams_Ncutpoints_get, _abarth.AbarthParams_Ncutpoints_set)
    __swig_setmethods__["burnin"] = _abarth.AbarthParams_burnin_set
    __swig_getmethods__["burnin"] = _abarth.AbarthParams_burnin_get
    if _newclass:
        burnin = _swig_property(_abarth.AbarthParams_burnin_get, _abarth.AbarthParams_burnin_set)
    __swig_setmethods__["mtry"] = _abarth.AbarthParams_mtry_set
    __swig_getmethods__["mtry"] = _abarth.AbarthParams_mtry_get
    if _newclass:
        mtry = _swig_property(_abarth.AbarthParams_mtry_get, _abarth.AbarthParams_mtry_set)
    __swig_setmethods__["max_depth_num"] = _abarth.AbarthParams_max_depth_num_set
    __swig_getmethods__["max_depth_num"] = _abarth.AbarthParams_max_depth_num_get
    if _newclass:
        max_depth_num = _swig_property(_abarth.AbarthParams_max_depth_num_get, _abarth.AbarthParams_max_depth_num_set)
    __swig_setmethods__["alpha"] = _abarth.AbarthParams_alpha_set
    __swig_getmethods__["alpha"] = _abarth.AbarthParams_alpha_get
    if _newclass:
        alpha = _swig_property(_abarth.AbarthParams_alpha_get, _abarth.AbarthParams_alpha_set)
    __swig_setmethods__["beta"] = _abarth.AbarthParams_beta_set
    __swig_getmethods__["beta"] = _abarth.AbarthParams_beta_get
    if _newclass:
        beta = _swig_property(_abarth.AbarthParams_beta_get, _abarth.AbarthParams_beta_set)
    __swig_setmethods__["tau"] = _abarth.AbarthParams_tau_set
    __swig_getmethods__["tau"] = _abarth.AbarthParams_tau_get
    if _newclass:
        tau = _swig_property(_abarth.AbarthParams_tau_get, _abarth.AbarthParams_tau_set)
    __swig_setmethods__["kap"] = _abarth.AbarthParams_kap_set
    __swig_getmethods__["kap"] = _abarth.AbarthParams_kap_get
    if _newclass:
        kap = _swig_property(_abarth.AbarthParams_kap_get, _abarth.AbarthParams_kap_set)
    __swig_setmethods__["s"] = _abarth.AbarthParams_s_set
    __swig_getmethods__["s"] = _abarth.AbarthParams_s_get
    if _newclass:
        s = _swig_property(_abarth.AbarthParams_s_get, _abarth.AbarthParams_s_set)
    __swig_setmethods__["draw_sigma"] = _abarth.AbarthParams_draw_sigma_set
    __swig_getmethods__["draw_sigma"] = _abarth.AbarthParams_draw_sigma_get
    if _newclass:
        draw_sigma = _swig_property(_abarth.AbarthParams_draw_sigma_get, _abarth.AbarthParams_draw_sigma_set)
    __swig_setmethods__["verbose"] = _abarth.AbarthParams_verbose_set
    __swig_getmethods__["verbose"] = _abarth.AbarthParams_verbose_get
    if _newclass:
        verbose = _swig_property(_abarth.AbarthParams_verbose_get, _abarth.AbarthParams_verbose_set)
    __swig_setmethods__["m_update_sigma"] = _abarth.AbarthParams_m_update_sigma_set
    __swig_getmethods__["m_update_sigma"] = _abarth.AbarthParams_m_update_sigma_get
    if _newclass:
        m_update_sigma = _swig_property(_abarth.AbarthParams_m_update_sigma_get, _abarth.AbarthParams_m_update_sigma_set)
    __swig_setmethods__["draw_mu"] = _abarth.AbarthParams_draw_mu_set
    __swig_getmethods__["draw_mu"] = _abarth.AbarthParams_draw_mu_get
    if _newclass:
        draw_mu = _swig_property(_abarth.AbarthParams_draw_mu_get, _abarth.AbarthParams_draw_mu_set)
    __swig_setmethods__["parallel"] = _abarth.AbarthParams_parallel_set
    __swig_getmethods__["parallel"] = _abarth.AbarthParams_parallel_get
    if _newclass:
        parallel = _swig_property(_abarth.AbarthParams_parallel_get, _abarth.AbarthParams_parallel_set)

    def __init__(self):
        this = _abarth.new_AbarthParams()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _abarth.delete_AbarthParams
    __del__ = lambda self: None
AbarthParams_swigregister = _abarth.AbarthParams_swigregister
AbarthParams_swigregister(AbarthParams)

class Abarth(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Abarth, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Abarth, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _abarth.new_Abarth(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _abarth.delete_Abarth
    __del__ = lambda self: None

    def get_M(self):
        return _abarth.Abarth_get_M(self)

    def get_N_sweeps(self):
        return _abarth.Abarth_get_N_sweeps(self)

    def get_burnin(self):
        return _abarth.Abarth_get_burnin(self)

    def fit(self, n):
        return _abarth.Abarth_fit(self, n)

    def fit_x(self, n):
        return _abarth.Abarth_fit_x(self, n)

    def sort_x(self, n, size):
        return _abarth.Abarth_sort_x(self, n, size)

    def predict(self, n, size):
        return _abarth.Abarth_predict(self, n, size)

    def __predict_2d(self, n, size):
        return _abarth.Abarth___predict_2d(self, n, size)

    def fit_predict(self, n, n_y, n_test, size):
        return _abarth.Abarth_fit_predict(self, n, n_y, n_test, size)

    def fit_predict_all(self, n, n_y, n_test, size, p_cat):
        return _abarth.Abarth_fit_predict_all(self, n, n_y, n_test, size, p_cat)

    def get_yhats(self, size):
        return _abarth.Abarth_get_yhats(self, size)

    def get_yhats_test(self, size):
        return _abarth.Abarth_get_yhats_test(self, size)

    def get_sigma_draw(self, size):
        return _abarth.Abarth_get_sigma_draw(self, size)

    def __convert_params_check_types(self,params):
    ### This function converts params to list and 
    ### It handles the types of params and raises exceptions if needed
    ### It puts in default values for empty param values 
        import warnings
        from collections import OrderedDict
        DEFAULT_PARAMS = OrderedDict([('M',200),('L',1),("N_sweeps",40)
                            ,("Nmin",1),("Ncutpoints",100) # CHANGE
                            ,("alpha",0.95),("beta",1.25 ),("tau",0.3),# CHANGE
                            ("burnin",15),("mtry",2),("max_depth_num",250), # CHANGE
                            ("draw_sigma",False),("kap",16),("s",4),("verbose",False),("m_update_sigma",False),
                            ("draw_mu",False),("parallel",False)])

        list_params = []
        for key,value in DEFAULT_PARAMS.items():
            true_type = type(value)
            new_value = params.get(key,value)
            if not isinstance(new_value,type(value)):  
                if true_type == int:
                    if isinstance(new_value,float):
                        if int(new_value) == new_value:
                            new_value = int(new_value)
                            warnings.warn("Value was of " + str(key) + " converted from float to int")
                        else:
                            raise TypeError(str(key) +" should be a positive integer value")
                    else:
                        raise TypeError(str(key) +" should be a positive integer")
                elif true_type == float:
                    if isinstance(new_value,int):
                        new_value = float(new_value)  
    ## warnings.warn("Value was of " + str(key) + " converted from int to float")          
                    else:
                        raise TypeError(str(key) + " should be a float")
                elif true_type == bool:
                    if int(new_value) in [0,1]:
                        new_value = bool(new_value)
                    else:    
                        raise TypeError(str(key) + " should be a bool")               
            list_params.append(new_value)             
        return list_params    

    def __init__(self,params = {}):

        assert isinstance(params, collections.Mapping), "params must be dictionary like"

        this = _abarth.new_Abarth(*self.__convert_params_check_types(params))

    # init
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this            




    def predict_2d(self,x):
    	x_pred = self.__predict_2d(x,x.shape[0]*x.shape[1])
    	return x_pred.reshape(x.shape)


    def fit_predict_2d(self,x,y,x_test):
        x_pred = self.fit_predict(x,y,x_test,y.shape[0])
        yhats_test = self.get_yhats_test(self.get_N_sweeps()*x_test.shape[0]).reshape((x_test.shape[0],self.get_N_sweeps()),order='C')
        return yhats_test


    def fit_predict_2d_all(self,x,y,x_test,p_cat=0):
        x_pred = self.fit_predict_all(x,y,x_test,y.shape[0],p_cat)
        yhats_test = self.get_yhats_test(self.get_N_sweeps()*x_test.shape[0]).reshape((x_test.shape[0],self.get_N_sweeps()),order='C')
        return yhats_test

Abarth_swigregister = _abarth.Abarth_swigregister
Abarth_swigregister(Abarth)

# This file is compatible with both classic and new-style classes.


